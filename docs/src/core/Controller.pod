=head1 NAME

MITHGrid.Controller

=head1 SYNOPSIS

 controller = MITHGrid.Controller.initController(type, { options list... });
 binding = controller.bind(DOMelement);

 raphaelController = MITHGrid.Controller.initRaphaelController(type, { options list... });
 binding = raphaelController.bind(RaphaelSVGElement);

=head1 DESCRIPTION

The controller manages all event bindings associated with a rendering. A controller is typically used by lenses to add
interactive elements to a rendering. The Raphaël controller initializer is used when the controller expects to work with
a Raphaël shape object instead of a DOM element.

=head1 EVENTS

The controller object has no events attached to it. Events may be configured for the element binding object using the C<bind>
configuration option.

=head1 METHODS

=head2 Constructor

 controller = MITHGrid.Controller.initController(type, { options list... });

=over 4

=item selectors

The C<selectors> option maps the handles used when setting up the element bindings to the actual CSS selectors used to find the
particular DOM elements that are children of the element being bound.

=item bind

The C<bind> option holds the configuration used to create the binding objects for particular elements.

=over 4

=item events

The C<events> option is used to configure the events for a particular element binding.

=back

=back

=head2 Controller Methods

=over 4

=item applyBindings(binding, args...)

This is an abstract method that must be defined in the controller. The arguments given to the L<bind> function are passed
in as-is. The C<binding> object provides access to the DOM in a configurable manner.

=item bind(el, args...)

This will apply bindings to the given element, returning the binding object. The binding object may have events
or other options if the controller provides them.

=item initBind(el)

This will create the binding object managing configurable access to parts of the rendered DOM.

=back

=head2 Binding Methods

The following methods are defined for the binding object passed into L<applyBindings> and returned by L<bind>.

=over 4

=item locate(selector)

This returns the DOM element indicated by the given selector. The C<selector> is the key into the L<selectors>
object passed into the controller constructor or indicated by the global defaults for the controller. This method
is key to allowing a controller to work with different DOM structures.

The special blank selector (C<''>) returns the top-level DOM element passed into the L<bind> method.

If called on a Raphaël controller, the special selector, C<raphael>, will return the top-level Raphaël shape object
similar to how the empty string (C<''>) returns the top-level DOM element.

=item fastLocate(selector)

Returns the cached DOM element if the selector has already been used. Otherwise, it falls back to the L<locate> method.
Since walking the DOM can be slow, this allows you to use the cached element if the selector was already looked up elsewhere.

=item refresh([ list of selectors ])

This will refresh the cache for the list of selectors. Nothing will be returned.

=item clear()

This will clear the selector cache.

=back

=head1 EXAMPLE

In this example, we discuss a controller that provides drag capability for objects in a Raphaël canvas.

 my.controller = function(options) {
   var that = MITHGrid.Controller.initRaphaelController("my.controller", options),
   options = that.options;

   that.applyBindings = function(binding, opts) {
     var ox, oy, svgEl;

     svgEl = binding.locate('raphael');
     svgEl.drag(
       function(dx, dy) {
         opts.model.updateItems([{
           id: opts.itemId,
           x: ox + dx,
           y: oy + dy
         }]);
       },
       function() {
         ox = parseInt(svgEl.attr(opts.x), 10);
         oy = parseInt(svgEl.attr(opts.y), 10);
       },
       function() {}
     );
   };

   return that;
 };

The first thing we do is create our base controller using the Raphaël controller since we're going to be binding to
a Raphaël object. This adds the special C<'raphael'> selector that returns the Raphaël shape object instead of the DOM node.

We then define the L<applyBindings> function that will add the drag bindings to the Raphaël object. Any information we need
in order to operate with the particular SVG shape needs to be passed in to the L<bind> function call. 

An example lens might use this controller as follows:

 myController = my.controller();
 
 lenses: {
   Type: function(container, view, model, id) {
     var el = /* rendering of the item using Raphaël */

     var binding = myController.bind(el, {
       model: model,
       itemId: id,
       x: 'x',
       y: 'y'
     });
   }
 }

We pass in C<model> and C<itemId> so the controller knows which item in which model we're working with. We also pass in
C<x> and C<y> so that the controller knows which attributes hold the current position of the Raphaël object.

We could use the binding object to access events or other functionality exposed by the controller.

=head1 SEE ALSO